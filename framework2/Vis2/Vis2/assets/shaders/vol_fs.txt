#version 440 core

#define NUM_SAMPLES 64

// dithering the beginning of the ray to avoid artifacts
float dither_pattern[16] = float[16] (
	0.0f, 0.5f, 0.125f, 0.625f,
	0.75f, 0.22f, 0.875f, 0.375f,
	0.1875f, 0.6875f, 0.0625f, 0.5625,
	0.9375f, 0.4375f, 0.8125f, 0.3125
);

in vec2 TexCoords;

out vec4 FragColor;

uniform mat4 inverseView;
uniform mat4 inverseProjection;
uniform vec3 viewPos;

// scene depth generated by rendering the cube beforehand
uniform sampler2D sceneDepth;

// our 3D texture
uniform sampler3D volTexture;

vec3 calculateWorldPos(float depth);
float castRayToFrag(vec3 fragPos);


// this is basically the ratio that the image creators have given between depth and width/height
// has to be moved out (for now just change it here if you wanna try another image)
float zRatio = 0.2409f / 0.1284f;

void main() {

	float depth = texture(sceneDepth, TexCoords).r;

	// just basic optimization to block useless rays
	if (depth > 0.99f) 
	{
		FragColor = vec4(0.0f);
		return;
	}
	
	vec3 fragPos = calculateWorldPos(depth);	
	vec3 one = vec3(1.0f, 1.0f, 1.0f);
	
	vec3 res = vec3(castRayToFrag(fragPos), 0, 0); 
	// screen blending
	vec3 result =  one - (one - res);

	FragColor = vec4(result, 0.5f);
}

// from screenspace position (our render cube depth map) to world space so we can shoot rays
vec3 calculateWorldPos(float depth) {
    vec4 clip_space_position = vec4(TexCoords * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
    vec4 view_space_position = inverseProjection * clip_space_position;

    // Perspective divide
    view_space_position /= view_space_position.w;

    vec4 world_space_position = inverseView * view_space_position;
    return world_space_position.xyz;
}

float castRayToFrag(vec3 fragPos) {	
	float dither = dither_pattern[ (int(gl_FragCoord.x) % 4) * 4 + (int(gl_FragCoord.y) % 4) ];
	float volume = 0.0;	
	
	// this is basically bullshit for now.
	// since we know where we render our model (in 1,1,1 cube in the middle lets say),
	// we should interset eye pos->frag with the cube and only start within the cube.
	// or alternatively, render the cube twice (once inside only, once outside)
	// and cast ray between the points between outside -> inside
	vec3 eyePos  = viewPos;	
			
	float remainingRayLength = length(eyePos - fragPos);
	float stepMagnitude = remainingRayLength / NUM_SAMPLES;

	vec3 stepMove =  stepMagnitude * normalize(eyePos - fragPos);		
	vec3 currentRayPosition = fragPos + dither * stepMove;	
			
	for (; remainingRayLength > stepMagnitude; remainingRayLength -= stepMagnitude) {

		if (length(currentRayPosition) < 0.6f) { 
			vec3 samplePosition = vec3(currentRayPosition) + vec3(0.5, 0.5, 0.5);
			samplePosition.xy *= zRatio;
			float texVal = texture(volTexture, samplePosition).r;

			// this is not physically correct. Just some calculations I played around to make it look neat.
			// I assume exp(textVal) - 1 is basically what the transform function should do
			// in an actual rendering.
			// anyways, this line is where the volume is build for each position of the ray.
			volume += (exp(texVal) - 1) * exp(-remainingRayLength/5) * 0.1;
		}

		currentRayPosition += stepMove;			
	}
	
	//clamp
	return min(volume, 1.0f) ;
}
